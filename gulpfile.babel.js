import bg from 'gulp-bg';
import eslint from 'gulp-eslint';
import gulp from 'gulp';
import makeWebpackConfig from './webpack/makeconfig';
import path from 'path';
import runSequence from 'run-sequence';
import webpackBuild from './webpack/build';
import webpackDevServer from './webpack/devserver';
import yargs from 'yargs';
import iconfont from 'gulp-iconfont';
import template from 'gulp-swig';
import rename from 'gulp-rename';
import browsersList from 'browserslist';
import {server as karmaServer} from 'karma';

const args = yargs
  .alias('p', 'production')
  .argv;

const runKarma = ({singleRun}, done) => {
  karmaServer.start({
    configFile: path.join(__dirname, 'karma.conf.js'), // eslint-disable-line no-undef
    singleRun: singleRun
  }, done);
};

gulp.task('env', () => {
  const env = args.production ? 'production' : 'development';
  process.env.NODE_ENV = env; // eslint-disable-line no-undef
});

gulp.task('build-webpack-production', webpackBuild(makeWebpackConfig(false)));
gulp.task('build-webpack-dev', webpackDevServer(makeWebpackConfig(true)));
gulp.task('build-webpack', [args.production
  ? 'build-webpack-production'
  : 'build-webpack-dev'
]);
gulp.task('build', ['build-webpack']);

gulp.task('eslint', () => {
  return gulp.src([
    'gulpfile.babel.js',
    'src/**/*.js',
    'webpack/*.js',
    '!**/__tests__/*.*'
  ])
  .pipe(eslint())
  .pipe(eslint.format())
  .pipe(eslint.failOnError());
});

gulp.task('karma-ci', (done) => {
  runKarma({singleRun: true}, done);
});

gulp.task('karma-dev', (done) => {
  runKarma({singleRun: false}, done);
});

gulp.task('test', (done) => {
  // Run test tasks serially, because it doesn't make sense to build when tests
  // are not passing, and it doesn't make sense to run tests, if lint has failed.
  // Gulp deps aren't helpful, because we want to run tasks without deps as well.
  runSequence('eslint', 'karma-ci', 'build-webpack-production', done);
});

// Font icons
var config = {
  name: 'Font Icons',
  src: './assets/icons/*.svg',
  dest: './assets/fonts',
  sassDest: './assets/css/base',
  template: './assets/css/icon_template.sass',
  sassOutputName: '_font_icons.sass',
  fontPath: '/assets/fonts',
  className: 'icon',
  options: {
    fontName: 'font-icons',
    appendUnicode: true,
    normalize: true
  }
};

var generateIconSass = function(glyphs, options) {
  var iconSass;
  iconSass = template({
    data: {
      icons: glyphs.map(function(icon) {
        return {
          name: icon.name,
          code: icon.unicode[0].charCodeAt(0).toString(16).toUpperCase()
        };
      }),
      fontName: config.options.fontName,
      fontPath: config.fontPath,
      className: config.className,
      comment: 'DO NOT EDIT DIRECTLY!\n  Generated by gulp fontIcons task'
    }
  });

  return gulp.src(config.template)
    .pipe(iconSass)
    .pipe(rename(config.sassOutputName))
    .pipe(gulp.dest(config.sassDest))
};

gulp.task('fontIcons', function() {
  return gulp.src(config.src)
    .pipe(iconfont(config.options)
    .on('glyphs', generateIconSass))
    .pipe(gulp.dest(config.dest))
});

// Browserlist
gulp.task('browserList', function() {
  var supportedBrowsers = makeWebpackConfig(require('./src/config/server')()).browserSupport;
  console.log(browsersList(supportedBrowsers));
});

gulp.task('server', ['env', 'build'], bg('node', 'src/server'));

gulp.task('default', (done) => {
  if (args.production)
    runSequence('server', done);
  else
    runSequence('server', 'karma-dev', done);
});
